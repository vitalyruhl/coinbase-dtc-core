#pragma once\n#include <string>\n#include <vector>\n#include <memory>\n#include <functional>\n#include <unordered_map>\n\nnamespace coinbase_dtc_core {\nnamespace feed {\n\n// Exchange-agnostic market data structures\nstruct MarketTrade {\n    std::string symbol;\n    std::string exchange;\n    double price;\n    double volume;\n    std::string side; // \"buy\" or \"sell\"\n    uint64_t timestamp;\n    std::string trade_id;\n};\n\nstruct MarketLevel2 {\n    std::string symbol;\n    std::string exchange;\n    double bid_price;\n    double bid_size;\n    double ask_price;\n    double ask_size;\n    uint64_t timestamp;\n};\n\n// Callback types for market data\nusing TradeCallback = std::function<void(const MarketTrade&)>;\nusing Level2Callback = std::function<void(const MarketLevel2&)>;\nusing ConnectionCallback = std::function<void(bool connected, const std::string& exchange)>;\nusing ErrorCallback = std::function<void(const std::string& error, const std::string& exchange)>;\n\n// Exchange configuration\nstruct ExchangeConfig {\n    std::string name;           // \"coinbase\", \"binance\", \"kraken\"\n    std::string websocket_url;\n    std::string api_url;\n    uint16_t port;\n    bool requires_auth;\n    std::string api_key;\n    std::string secret_key;\n    std::string passphrase;     // For Coinbase Pro\n    \n    ExchangeConfig() : port(443), requires_auth(false) {}\n};\n\n// Abstract base class for exchange market data feeds\nclass ExchangeFeed {\npublic:\n    ExchangeFeed(const ExchangeConfig& config) : config_(config) {}\n    virtual ~ExchangeFeed() = default;\n    \n    // Core interface - must be implemented by each exchange\n    virtual bool connect() = 0;\n    virtual void disconnect() = 0;\n    virtual bool is_connected() const = 0;\n    \n    virtual bool subscribe_trades(const std::string& symbol) = 0;\n    virtual bool subscribe_level2(const std::string& symbol) = 0;\n    virtual bool unsubscribe(const std::string& symbol) = 0;\n    virtual bool subscribe_multiple_symbols(const std::vector<std::string>& symbols) = 0;\n    \n    // Exchange-specific symbol mapping (override per exchange)\n    virtual std::string normalize_symbol(const std::string& exchange_symbol) = 0;\n    virtual std::string exchange_symbol(const std::string& normalized_symbol) = 0;\n    virtual std::vector<std::string> get_available_symbols() = 0;\n    \n    // Callback management\n    void set_trade_callback(TradeCallback callback) { trade_callback_ = callback; }\n    void set_level2_callback(Level2Callback callback) { level2_callback_ = callback; }\n    void set_connection_callback(ConnectionCallback callback) { connection_callback_ = callback; }\n    void set_error_callback(ErrorCallback callback) { error_callback_ = callback; }\n    \n    // Configuration\n    const ExchangeConfig& get_config() const { return config_; }\n    std::string get_exchange_name() const { return config_.name; }\n    \n    // Status and statistics\n    virtual std::string get_status() const = 0;\n    virtual std::vector<std::string> get_subscribed_symbols() const = 0;\n    \nprotected:\n    // Helper methods for derived classes\n    void notify_trade(const MarketTrade& trade) {\n        if (trade_callback_) trade_callback_(trade);\n    }\n    \n    void notify_level2(const MarketLevel2& level2) {\n        if (level2_callback_) level2_callback_(level2);\n    }\n    \n    void notify_connection(bool connected) {\n        if (connection_callback_) connection_callback_(connected, config_.name);\n    }\n    \n    void notify_error(const std::string& error) {\n        if (error_callback_) error_callback_(error, config_.name);\n    }\n    \n    ExchangeConfig config_;\n    \nprivate:\n    TradeCallback trade_callback_;\n    Level2Callback level2_callback_;\n    ConnectionCallback connection_callback_;\n    ErrorCallback error_callback_;\n};\n\n// Exchange factory for creating feed instances\nclass ExchangeFactory {\npublic:\n    static std::unique_ptr<ExchangeFeed> create_feed(const ExchangeConfig& config);\n    static std::vector<std::string> get_supported_exchanges();\n    static ExchangeConfig get_default_config(const std::string& exchange_name);\n};\n\n// Multi-exchange aggregator\nclass MultiExchangeFeed {\npublic:\n    MultiExchangeFeed();\n    ~MultiExchangeFeed();\n    \n    // Exchange management\n    bool add_exchange(const ExchangeConfig& config);\n    bool remove_exchange(const std::string& exchange_name);\n    std::vector<std::string> get_active_exchanges() const;\n    \n    // Symbol subscription across exchanges\n    bool subscribe_symbol(const std::string& symbol, const std::string& exchange = \"\"); // Empty = all exchanges\n    bool unsubscribe_symbol(const std::string& symbol, const std::string& exchange = \"\");\n    \n    // Callbacks - aggregates from all exchanges\n    void set_trade_callback(TradeCallback callback) { trade_callback_ = callback; }\n    void set_level2_callback(Level2Callback callback) { level2_callback_ = callback; }\n    \n    // Status\n    std::string get_status() const;\n    size_t get_total_subscriptions() const;\n    \nprivate:\n    std::unordered_map<std::string, std::unique_ptr<ExchangeFeed>> exchanges_;\n    std::mutex exchanges_mutex_;\n    \n    TradeCallback trade_callback_;\n    Level2Callback level2_callback_;\n    \n    void on_trade_data(const MarketTrade& trade);\n    void on_level2_data(const MarketLevel2& level2);\n};\n\n} // namespace feed\n} // namespace coinbase_dtc_core"