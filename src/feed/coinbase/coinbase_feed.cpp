#include \"coinbase_dtc_core/feed/coinbase/coinbase_feed.hpp\"\n#include \"coinbase_dtc_core/util/log.hpp\"\n#include <iostream>\n#include <sstream>\n#include <chrono>\n#include <random>\n#include <algorithm>\n\nnamespace coinbase_dtc_core {\nnamespace feed {\nnamespace coinbase {\n\nCoinbaseFeed::CoinbaseFeed(const ExchangeConfig& config)\n    : ExchangeFeed(config)\n    , connected_(false)\n    , should_stop_(false)\n    , socket_(-1)\n    , messages_received_(0)\n    , messages_sent_(0)\n    , last_message_time_(0) {\n    \n    initialize_symbol_mappings();\n    util::log(\"[COINBASE] Feed initialized\");\n}\n\nCoinbaseFeed::~CoinbaseFeed() {\n    disconnect();\n    util::log(\"[COINBASE] Feed destroyed\");\n}\n\nbool CoinbaseFeed::connect() {\n    if (connected_.load()) {\n        return true;\n    }\n    \n    util::log(\"[COINBASE] Connecting to \" + config_.websocket_url);\n    \n    // For now, simulate connection (real WebSocket implementation would go here)\n    connected_.store(true);\n    should_stop_.store(false);\n    \n    // Start worker threads\n    worker_thread_ = std::thread(&CoinbaseFeed::worker_loop, this);\n    ping_thread_ = std::thread(&CoinbaseFeed::ping_loop, this);\n    \n    notify_connection(true);\n    util::log(\"[COINBASE] Connected successfully\");\n    return true;\n}\n\nvoid CoinbaseFeed::disconnect() {\n    if (!connected_.load()) {\n        return;\n    }\n    \n    util::log(\"[COINBASE] Disconnecting...\");\n    \n    should_stop_.store(true);\n    connected_.store(false);\n    \n    // Wait for threads to finish\n    if (worker_thread_.joinable()) {\n        worker_thread_.join();\n    }\n    if (ping_thread_.joinable()) {\n        ping_thread_.join();\n    }\n    \n    cleanup_socket();\n    notify_connection(false);\n    util::log(\"[COINBASE] Disconnected\");\n}\n\nbool CoinbaseFeed::is_connected() const {\n    return connected_.load();\n}\n\nbool CoinbaseFeed::subscribe_trades(const std::string& symbol) {\n    if (!connected_.load()) {\n        return false;\n    }\n    \n    std::string coinbase_symbol = exchange_symbol(symbol);\n    \n    {\n        std::lock_guard<std::mutex> lock(subscriptions_mutex_);\n        auto it = std::find(subscribed_symbols_.begin(), subscribed_symbols_.end(), coinbase_symbol);\n        if (it == subscribed_symbols_.end()) {\n            subscribed_symbols_.push_back(coinbase_symbol);\n        }\n    }\n    \n    util::log(\"[COINBASE] Subscribed to trades for \" + coinbase_symbol);\n    return true;\n}\n\nbool CoinbaseFeed::subscribe_level2(const std::string& symbol) {\n    if (!connected_.load()) {\n        return false;\n    }\n    \n    std::string coinbase_symbol = exchange_symbol(symbol);\n    util::log(\"[COINBASE] Subscribed to level2 for \" + coinbase_symbol);\n    return true;\n}\n\nbool CoinbaseFeed::unsubscribe(const std::string& symbol) {\n    std::string coinbase_symbol = exchange_symbol(symbol);\n    \n    {\n        std::lock_guard<std::mutex> lock(subscriptions_mutex_);\n        auto it = std::find(subscribed_symbols_.begin(), subscribed_symbols_.end(), coinbase_symbol);\n        if (it != subscribed_symbols_.end()) {\n            subscribed_symbols_.erase(it);\n        }\n    }\n    \n    util::log(\"[COINBASE] Unsubscribed from \" + coinbase_symbol);\n    return true;\n}\n\nbool CoinbaseFeed::subscribe_multiple_symbols(const std::vector<std::string>& symbols) {\n    bool all_success = true;\n    for (const auto& symbol : symbols) {\n        if (!subscribe_trades(symbol) || !subscribe_level2(symbol)) {\n            all_success = false;\n        }\n    }\n    return all_success;\n}\n\nstd::string CoinbaseFeed::normalize_symbol(const std::string& coinbase_symbol) {\n    auto it = coinbase_to_normalized_.find(coinbase_symbol);\n    if (it != coinbase_to_normalized_.end()) {\n        return it->second;\n    }\n    return coinbase_symbol; // Return as-is if not found\n}\n\nstd::string CoinbaseFeed::exchange_symbol(const std::string& normalized_symbol) {\n    auto it = normalized_to_coinbase_.find(normalized_symbol);\n    if (it != normalized_to_coinbase_.end()) {\n        return it->second;\n    }\n    return normalized_symbol; // Return as-is if not found\n}\n\nstd::vector<std::string> CoinbaseFeed::get_available_symbols() {\n    std::vector<std::string> symbols;\n    for (const auto& [normalized, coinbase] : normalized_to_coinbase_) {\n        symbols.push_back(normalized);\n    }\n    return symbols;\n}\n\nstd::string CoinbaseFeed::get_status() const {\n    std::ostringstream ss;\n    ss << \"Coinbase Feed Status:\\n\";\n    ss << \"  Connected: \" << (connected_.load() ? \"Yes\" : \"No\") << \"\\n\";\n    ss << \"  WebSocket URL: \" << config_.websocket_url << \"\\n\";\n    ss << \"  Subscribed Symbols: \" << get_subscribed_symbols().size() << \"\\n\";\n    ss << \"  Messages Received: \" << messages_received_.load() << \"\\n\";\n    ss << \"  Messages Sent: \" << messages_sent_.load() << \"\\n\";\n    return ss.str();\n}\n\nstd::vector<std::string> CoinbaseFeed::get_subscribed_symbols() const {\n    std::lock_guard<std::mutex> lock(subscriptions_mutex_);\n    return subscribed_symbols_;\n}\n\nvoid CoinbaseFeed::worker_loop() {\n    util::log(\"[COINBASE] Worker thread started\");\n    \n    std::random_device rd;\n    std::mt19937 gen(rd());\n    \n    // Realistic price ranges for symbols\n    std::unordered_map<std::string, std::pair<double, double>> price_ranges = {\n        {\"STRK-USDC\", {0.45, 0.65}},\n        {\"USDC-EUR\", {0.85, 0.95}},\n        {\"SOL-USDC\", {180.0, 220.0}},\n        {\"BTC-USDC\", {85000.0, 95000.0}},\n        {\"ETH-USDC\", {3200.0, 3800.0}},\n        {\"LTC-USDC\", {85.0, 105.0}},\n        {\"LINK-USDC\", {18.0, 25.0}},\n        {\"XRP-USDC\", {1.10, 1.35}},\n        {\"ADA-USDC\", {0.85, 1.15}}\n    };\n    \n    while (!should_stop_.load() && connected_.load()) {\n        auto current_time = get_current_timestamp();\n        \n        // Get currently subscribed symbols\n        std::vector<std::string> symbols;\n        {\n            std::lock_guard<std::mutex> lock(subscriptions_mutex_);\n            symbols = subscribed_symbols_;\n        }\n        \n        // Generate data for each subscribed symbol\n        for (const auto& coinbase_symbol : symbols) {\n            std::string normalized_symbol = normalize_symbol(coinbase_symbol);\n            \n            auto price_it = price_ranges.find(coinbase_symbol);\n            if (price_it == price_ranges.end()) continue;\n            \n            double min_price = price_it->second.first;\n            double max_price = price_it->second.second;\n            std::uniform_real_distribution<> price_dist(min_price, max_price);\n            std::uniform_real_distribution<> volume_dist(0.001, 0.500);\n            std::uniform_real_distribution<> spread_dist(0.001, 0.005);\n            \n            // Generate trade data\n            MarketTrade trade;\n            trade.symbol = normalized_symbol;\n            trade.exchange = \"coinbase\";\n            trade.price = price_dist(gen);\n            trade.volume = volume_dist(gen);\n            trade.side = (gen() % 2) ? \"buy\" : \"sell\";\n            trade.timestamp = current_time;\n            trade.trade_id = \"coinbase-\" + std::to_string(current_time);\n            \n            notify_trade(trade);\n            \n            // Generate level2 data\n            MarketLevel2 level2;\n            level2.symbol = normalized_symbol;\n            level2.exchange = \"coinbase\";\n            double base_price = price_dist(gen);\n            double spread_pct = spread_dist(gen);\n            level2.bid_price = base_price * (1.0 - spread_pct);\n            level2.ask_price = base_price * (1.0 + spread_pct);\n            level2.bid_size = volume_dist(gen) * 10;\n            level2.ask_size = volume_dist(gen) * 10;\n            level2.timestamp = current_time;\n            \n            notify_level2(level2);\n            \n            messages_received_ += 2; // Trade + Level2\n            last_message_time_.store(current_time);\n        }\n        \n        // Wait before next update\n        if (!should_stop_.load()) {\n            std::this_thread::sleep_for(std::chrono::milliseconds(1000 + (gen() % 1000)));\n        }\n    }\n    \n    util::log(\"[COINBASE] Worker thread stopped\");\n}\n\nvoid CoinbaseFeed::ping_loop() {\n    while (!should_stop_.load() && connected_.load()) {\n        std::this_thread::sleep_for(std::chrono::seconds(30));\n        \n        if (connected_.load()) {\n            messages_sent_++;\n        }\n    }\n}\n\nstd::string CoinbaseFeed::create_subscribe_message(const std::string& channel, const std::string& product_id) const {\n    return \"{\\\"type\\\":\\\"subscribe\\\",\\\"channels\\\":[{\\\"name\\\":\\\"\" + channel + \"\\\",\\\"product_ids\\\":[\\\"\" + product_id + \"\\\"]}]}\";\n}\n\nstd::string CoinbaseFeed::create_unsubscribe_message(const std::string& product_id) const {\n    return \"{\\\"type\\\":\\\"unsubscribe\\\",\\\"product_ids\\\":[\\\"\" + product_id + \"\\\"]}\";\n}\n\nvoid CoinbaseFeed::initialize_symbol_mappings() {\n    // Map normalized symbols to Coinbase format\n    std::vector<std::pair<std::string, std::string>> mappings = {\n        {\"STRK/USDC\", \"STRK-USDC\"},\n        {\"USDC/EUR\", \"USDC-EUR\"},\n        {\"SOL/USDC\", \"SOL-USDC\"},\n        {\"BTC/USDC\", \"BTC-USDC\"},\n        {\"ETH/USDC\", \"ETH-USDC\"},\n        {\"LTC/USDC\", \"LTC-USDC\"},\n        {\"LINK/USDC\", \"LINK-USDC\"},\n        {\"XRP/USDC\", \"XRP-USDC\"},\n        {\"ADA/USDC\", \"ADA-USDC\"}\n    };\n    \n    for (const auto& [normalized, coinbase] : mappings) {\n        normalized_to_coinbase_[normalized] = coinbase;\n        coinbase_to_normalized_[coinbase] = normalized;\n    }\n    \n    util::log(\"[COINBASE] Initialized \" + std::to_string(mappings.size()) + \" symbol mappings\");\n}\n\nvoid CoinbaseFeed::cleanup_socket() {\n    if (socket_ != -1) {\n        #ifdef _WIN32\n        closesocket(socket_);\n        #else\n        close(socket_);\n        #endif\n        socket_ = -1;\n    }\n}\n\nuint64_t CoinbaseFeed::get_current_timestamp() const {\n    auto now = std::chrono::high_resolution_clock::now();\n    auto duration = now.time_since_epoch();\n    return std::chrono::duration_cast<std::chrono::microseconds>(duration).count();\n}\n\n} // namespace coinbase\n} // namespace feed\n} // namespace coinbase_dtc_core"