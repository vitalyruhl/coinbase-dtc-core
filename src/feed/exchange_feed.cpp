#include \"coinbase_dtc_core/feed/exchange_feed.hpp\"\n#include \"coinbase_dtc_core/feed/coinbase/coinbase_feed.hpp\"\n#include \"coinbase_dtc_core/feed/binance/binance_feed.hpp\"\n#include \"coinbase_dtc_core/util/log.hpp\"\n#include <stdexcept>\n\nnamespace coinbase_dtc_core {\nnamespace feed {\n\n// Exchange Factory Implementation\nstd::unique_ptr<ExchangeFeed> ExchangeFactory::create_feed(const ExchangeConfig& config) {\n    util::log(\"[FACTORY] Creating feed for exchange: \" + config.name);\n    \n    if (config.name == \"coinbase\") {\n        return std::make_unique<coinbase::CoinbaseFeed>(config);\n    } else if (config.name == \"binance\") {\n        return std::make_unique<binance::BinanceFeed>(config);\n    } else {\n        throw std::runtime_error(\"Unsupported exchange: \" + config.name);\n    }\n}\n\nstd::vector<std::string> ExchangeFactory::get_supported_exchanges() {\n    return {\"coinbase\", \"binance\"};\n}\n\nExchangeConfig ExchangeFactory::get_default_config(const std::string& exchange_name) {\n    ExchangeConfig config;\n    config.name = exchange_name;\n    \n    if (exchange_name == \"coinbase\") {\n        config.websocket_url = \"wss://ws-feed.exchange.coinbase.com\";\n        config.api_url = \"https://api.exchange.coinbase.com\";\n        config.port = 443;\n        config.requires_auth = false; // For market data\n        \n    } else if (exchange_name == \"binance\") {\n        config.websocket_url = \"wss://stream.binance.com:9443/ws\";\n        config.api_url = \"https://api.binance.com\";\n        config.port = 443;\n        config.requires_auth = false; // For market data\n        \n    } else {\n        throw std::runtime_error(\"Unknown exchange: \" + exchange_name);\n    }\n    \n    return config;\n}\n\n// Multi-Exchange Feed Implementation\nMultiExchangeFeed::MultiExchangeFeed() {\n    util::log(\"[MULTI] Multi-exchange feed initialized\");\n}\n\nMultiExchangeFeed::~MultiExchangeFeed() {\n    // Disconnect all exchanges\n    for (auto& [name, feed] : exchanges_) {\n        if (feed && feed->is_connected()) {\n            feed->disconnect();\n        }\n    }\n    util::log(\"[MULTI] Multi-exchange feed destroyed\");\n}\n\nbool MultiExchangeFeed::add_exchange(const ExchangeConfig& config) {\n    std::lock_guard<std::mutex> lock(exchanges_mutex_);\n    \n    if (exchanges_.find(config.name) != exchanges_.end()) {\n        util::log(\"[MULTI] Exchange \" + config.name + \" already exists\");\n        return false;\n    }\n    \n    try {\n        auto feed = ExchangeFactory::create_feed(config);\n        \n        // Set callbacks to aggregate data\n        feed->set_trade_callback([this](const MarketTrade& trade) {\n            this->on_trade_data(trade);\n        });\n        \n        feed->set_level2_callback([this](const MarketLevel2& level2) {\n            this->on_level2_data(level2);\n        });\n        \n        exchanges_[config.name] = std::move(feed);\n        \n        util::log(\"[MULTI] Added exchange: \" + config.name);\n        return true;\n        \n    } catch (const std::exception& e) {\n        util::log(\"[MULTI] Failed to add exchange \" + config.name + \": \" + e.what());\n        return false;\n    }\n}\n\nbool MultiExchangeFeed::remove_exchange(const std::string& exchange_name) {\n    std::lock_guard<std::mutex> lock(exchanges_mutex_);\n    \n    auto it = exchanges_.find(exchange_name);\n    if (it == exchanges_.end()) {\n        return false;\n    }\n    \n    if (it->second->is_connected()) {\n        it->second->disconnect();\n    }\n    \n    exchanges_.erase(it);\n    util::log(\"[MULTI] Removed exchange: \" + exchange_name);\n    return true;\n}\n\nstd::vector<std::string> MultiExchangeFeed::get_active_exchanges() const {\n    std::lock_guard<std::mutex> lock(exchanges_mutex_);\n    \n    std::vector<std::string> active;\n    for (const auto& [name, feed] : exchanges_) {\n        if (feed && feed->is_connected()) {\n            active.push_back(name);\n        }\n    }\n    return active;\n}\n\nbool MultiExchangeFeed::subscribe_symbol(const std::string& symbol, const std::string& exchange) {\n    std::lock_guard<std::mutex> lock(exchanges_mutex_);\n    \n    bool success = false;\n    \n    if (exchange.empty()) {\n        // Subscribe on all exchanges\n        for (auto& [name, feed] : exchanges_) {\n            if (feed && feed->is_connected()) {\n                if (feed->subscribe_trades(symbol) && feed->subscribe_level2(symbol)) {\n                    success = true;\n                    util::log(\"[MULTI] Subscribed \" + symbol + \" on \" + name);\n                }\n            }\n        }\n    } else {\n        // Subscribe on specific exchange\n        auto it = exchanges_.find(exchange);\n        if (it != exchanges_.end() && it->second && it->second->is_connected()) {\n            success = it->second->subscribe_trades(symbol) && it->second->subscribe_level2(symbol);\n            if (success) {\n                util::log(\"[MULTI] Subscribed \" + symbol + \" on \" + exchange);\n            }\n        }\n    }\n    \n    return success;\n}\n\nbool MultiExchangeFeed::unsubscribe_symbol(const std::string& symbol, const std::string& exchange) {\n    std::lock_guard<std::mutex> lock(exchanges_mutex_);\n    \n    bool success = false;\n    \n    if (exchange.empty()) {\n        // Unsubscribe from all exchanges\n        for (auto& [name, feed] : exchanges_) {\n            if (feed && feed->is_connected()) {\n                if (feed->unsubscribe(symbol)) {\n                    success = true;\n                    util::log(\"[MULTI] Unsubscribed \" + symbol + \" from \" + name);\n                }\n            }\n        }\n    } else {\n        // Unsubscribe from specific exchange\n        auto it = exchanges_.find(exchange);\n        if (it != exchanges_.end() && it->second) {\n            success = it->second->unsubscribe(symbol);\n            if (success) {\n                util::log(\"[MULTI] Unsubscribed \" + symbol + \" from \" + exchange);\n            }\n        }\n    }\n    \n    return success;\n}\n\nstd::string MultiExchangeFeed::get_status() const {\n    std::lock_guard<std::mutex> lock(exchanges_mutex_);\n    \n    std::ostringstream ss;\n    ss << \"Multi-Exchange Feed Status:\\n\";\n    ss << \"  Active Exchanges: \" << exchanges_.size() << \"\\n\";\n    \n    for (const auto& [name, feed] : exchanges_) {\n        ss << \"  \" << name << \": \" << (feed->is_connected() ? \"Connected\" : \"Disconnected\") << \"\\n\";\n    }\n    \n    return ss.str();\n}\n\nsize_t MultiExchangeFeed::get_total_subscriptions() const {\n    std::lock_guard<std::mutex> lock(exchanges_mutex_);\n    \n    size_t total = 0;\n    for (const auto& [name, feed] : exchanges_) {\n        if (feed) {\n            total += feed->get_subscribed_symbols().size();\n        }\n    }\n    return total;\n}\n\nvoid MultiExchangeFeed::on_trade_data(const MarketTrade& trade) {\n    if (trade_callback_) {\n        trade_callback_(trade);\n    }\n}\n\nvoid MultiExchangeFeed::on_level2_data(const MarketLevel2& level2) {\n    if (level2_callback_) {\n        level2_callback_(level2);\n    }\n}\n\n} // namespace feed\n} // namespace coinbase_dtc_core"